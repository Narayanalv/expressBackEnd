
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck 
/*
 * This file exports the `UserFav` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model UserFav
 * 
 */
export type UserFavModel = runtime.Types.Result.DefaultSelection<Prisma.$UserFavPayload>

export type AggregateUserFav = {
  _count: UserFavCountAggregateOutputType | null
  _avg: UserFavAvgAggregateOutputType | null
  _sum: UserFavSumAggregateOutputType | null
  _min: UserFavMinAggregateOutputType | null
  _max: UserFavMaxAggregateOutputType | null
}

export type UserFavAvgAggregateOutputType = {
  id: number | null
  userId: number | null
}

export type UserFavSumAggregateOutputType = {
  id: number | null
  userId: number | null
}

export type UserFavMinAggregateOutputType = {
  id: number | null
  userId: number | null
  active: boolean | null
  title: string | null
  type: string | null
  director: string | null
  budget: string | null
  location: string | null
  duration: string | null
  time: string | null
  image: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type UserFavMaxAggregateOutputType = {
  id: number | null
  userId: number | null
  active: boolean | null
  title: string | null
  type: string | null
  director: string | null
  budget: string | null
  location: string | null
  duration: string | null
  time: string | null
  image: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type UserFavCountAggregateOutputType = {
  id: number
  userId: number
  active: number
  title: number
  type: number
  director: number
  budget: number
  location: number
  duration: number
  time: number
  image: number
  createdAt: number
  updatedAt: number
  _all: number
}


export type UserFavAvgAggregateInputType = {
  id?: true
  userId?: true
}

export type UserFavSumAggregateInputType = {
  id?: true
  userId?: true
}

export type UserFavMinAggregateInputType = {
  id?: true
  userId?: true
  active?: true
  title?: true
  type?: true
  director?: true
  budget?: true
  location?: true
  duration?: true
  time?: true
  image?: true
  createdAt?: true
  updatedAt?: true
}

export type UserFavMaxAggregateInputType = {
  id?: true
  userId?: true
  active?: true
  title?: true
  type?: true
  director?: true
  budget?: true
  location?: true
  duration?: true
  time?: true
  image?: true
  createdAt?: true
  updatedAt?: true
}

export type UserFavCountAggregateInputType = {
  id?: true
  userId?: true
  active?: true
  title?: true
  type?: true
  director?: true
  budget?: true
  location?: true
  duration?: true
  time?: true
  image?: true
  createdAt?: true
  updatedAt?: true
  _all?: true
}

export type UserFavAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which UserFav to aggregate.
   */
  where?: Prisma.UserFavWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of UserFavs to fetch.
   */
  orderBy?: Prisma.UserFavOrderByWithRelationInput | Prisma.UserFavOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.UserFavWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` UserFavs from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` UserFavs.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned UserFavs
  **/
  _count?: true | UserFavCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: UserFavAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: UserFavSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: UserFavMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: UserFavMaxAggregateInputType
}

export type GetUserFavAggregateType<T extends UserFavAggregateArgs> = {
      [P in keyof T & keyof AggregateUserFav]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateUserFav[P]>
    : Prisma.GetScalarType<T[P], AggregateUserFav[P]>
}




export type UserFavGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.UserFavWhereInput
  orderBy?: Prisma.UserFavOrderByWithAggregationInput | Prisma.UserFavOrderByWithAggregationInput[]
  by: Prisma.UserFavScalarFieldEnum[] | Prisma.UserFavScalarFieldEnum
  having?: Prisma.UserFavScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: UserFavCountAggregateInputType | true
  _avg?: UserFavAvgAggregateInputType
  _sum?: UserFavSumAggregateInputType
  _min?: UserFavMinAggregateInputType
  _max?: UserFavMaxAggregateInputType
}

export type UserFavGroupByOutputType = {
  id: number
  userId: number
  active: boolean
  title: string
  type: string
  director: string
  budget: string
  location: string
  duration: string
  time: string
  image: string
  createdAt: Date
  updatedAt: Date
  _count: UserFavCountAggregateOutputType | null
  _avg: UserFavAvgAggregateOutputType | null
  _sum: UserFavSumAggregateOutputType | null
  _min: UserFavMinAggregateOutputType | null
  _max: UserFavMaxAggregateOutputType | null
}

type GetUserFavGroupByPayload<T extends UserFavGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<UserFavGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof UserFavGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], UserFavGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], UserFavGroupByOutputType[P]>
      }
    >
  >



export type UserFavWhereInput = {
  AND?: Prisma.UserFavWhereInput | Prisma.UserFavWhereInput[]
  OR?: Prisma.UserFavWhereInput[]
  NOT?: Prisma.UserFavWhereInput | Prisma.UserFavWhereInput[]
  id?: Prisma.IntFilter<"UserFav"> | number
  userId?: Prisma.IntFilter<"UserFav"> | number
  active?: Prisma.BoolFilter<"UserFav"> | boolean
  title?: Prisma.StringFilter<"UserFav"> | string
  type?: Prisma.StringFilter<"UserFav"> | string
  director?: Prisma.StringFilter<"UserFav"> | string
  budget?: Prisma.StringFilter<"UserFav"> | string
  location?: Prisma.StringFilter<"UserFav"> | string
  duration?: Prisma.StringFilter<"UserFav"> | string
  time?: Prisma.StringFilter<"UserFav"> | string
  image?: Prisma.StringFilter<"UserFav"> | string
  createdAt?: Prisma.DateTimeFilter<"UserFav"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"UserFav"> | Date | string
  user?: Prisma.XOR<Prisma.UserCredScalarRelationFilter, Prisma.UserCredWhereInput>
}

export type UserFavOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  active?: Prisma.SortOrder
  title?: Prisma.SortOrder
  type?: Prisma.SortOrder
  director?: Prisma.SortOrder
  budget?: Prisma.SortOrder
  location?: Prisma.SortOrder
  duration?: Prisma.SortOrder
  time?: Prisma.SortOrder
  image?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  user?: Prisma.UserCredOrderByWithRelationInput
  _relevance?: Prisma.UserFavOrderByRelevanceInput
}

export type UserFavWhereUniqueInput = Prisma.AtLeast<{
  id?: number
  AND?: Prisma.UserFavWhereInput | Prisma.UserFavWhereInput[]
  OR?: Prisma.UserFavWhereInput[]
  NOT?: Prisma.UserFavWhereInput | Prisma.UserFavWhereInput[]
  userId?: Prisma.IntFilter<"UserFav"> | number
  active?: Prisma.BoolFilter<"UserFav"> | boolean
  title?: Prisma.StringFilter<"UserFav"> | string
  type?: Prisma.StringFilter<"UserFav"> | string
  director?: Prisma.StringFilter<"UserFav"> | string
  budget?: Prisma.StringFilter<"UserFav"> | string
  location?: Prisma.StringFilter<"UserFav"> | string
  duration?: Prisma.StringFilter<"UserFav"> | string
  time?: Prisma.StringFilter<"UserFav"> | string
  image?: Prisma.StringFilter<"UserFav"> | string
  createdAt?: Prisma.DateTimeFilter<"UserFav"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"UserFav"> | Date | string
  user?: Prisma.XOR<Prisma.UserCredScalarRelationFilter, Prisma.UserCredWhereInput>
}, "id">

export type UserFavOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  active?: Prisma.SortOrder
  title?: Prisma.SortOrder
  type?: Prisma.SortOrder
  director?: Prisma.SortOrder
  budget?: Prisma.SortOrder
  location?: Prisma.SortOrder
  duration?: Prisma.SortOrder
  time?: Prisma.SortOrder
  image?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  _count?: Prisma.UserFavCountOrderByAggregateInput
  _avg?: Prisma.UserFavAvgOrderByAggregateInput
  _max?: Prisma.UserFavMaxOrderByAggregateInput
  _min?: Prisma.UserFavMinOrderByAggregateInput
  _sum?: Prisma.UserFavSumOrderByAggregateInput
}

export type UserFavScalarWhereWithAggregatesInput = {
  AND?: Prisma.UserFavScalarWhereWithAggregatesInput | Prisma.UserFavScalarWhereWithAggregatesInput[]
  OR?: Prisma.UserFavScalarWhereWithAggregatesInput[]
  NOT?: Prisma.UserFavScalarWhereWithAggregatesInput | Prisma.UserFavScalarWhereWithAggregatesInput[]
  id?: Prisma.IntWithAggregatesFilter<"UserFav"> | number
  userId?: Prisma.IntWithAggregatesFilter<"UserFav"> | number
  active?: Prisma.BoolWithAggregatesFilter<"UserFav"> | boolean
  title?: Prisma.StringWithAggregatesFilter<"UserFav"> | string
  type?: Prisma.StringWithAggregatesFilter<"UserFav"> | string
  director?: Prisma.StringWithAggregatesFilter<"UserFav"> | string
  budget?: Prisma.StringWithAggregatesFilter<"UserFav"> | string
  location?: Prisma.StringWithAggregatesFilter<"UserFav"> | string
  duration?: Prisma.StringWithAggregatesFilter<"UserFav"> | string
  time?: Prisma.StringWithAggregatesFilter<"UserFav"> | string
  image?: Prisma.StringWithAggregatesFilter<"UserFav"> | string
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"UserFav"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"UserFav"> | Date | string
}

export type UserFavCreateInput = {
  active?: boolean
  title: string
  type: string
  director: string
  budget: string
  location: string
  duration: string
  time: string
  image: string
  createdAt?: Date | string
  updatedAt?: Date | string
  user: Prisma.UserCredCreateNestedOneWithoutUserFavInput
}

export type UserFavUncheckedCreateInput = {
  id?: number
  userId: number
  active?: boolean
  title: string
  type: string
  director: string
  budget: string
  location: string
  duration: string
  time: string
  image: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type UserFavUpdateInput = {
  active?: Prisma.BoolFieldUpdateOperationsInput | boolean
  title?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  director?: Prisma.StringFieldUpdateOperationsInput | string
  budget?: Prisma.StringFieldUpdateOperationsInput | string
  location?: Prisma.StringFieldUpdateOperationsInput | string
  duration?: Prisma.StringFieldUpdateOperationsInput | string
  time?: Prisma.StringFieldUpdateOperationsInput | string
  image?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserCredUpdateOneRequiredWithoutUserFavNestedInput
}

export type UserFavUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  active?: Prisma.BoolFieldUpdateOperationsInput | boolean
  title?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  director?: Prisma.StringFieldUpdateOperationsInput | string
  budget?: Prisma.StringFieldUpdateOperationsInput | string
  location?: Prisma.StringFieldUpdateOperationsInput | string
  duration?: Prisma.StringFieldUpdateOperationsInput | string
  time?: Prisma.StringFieldUpdateOperationsInput | string
  image?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type UserFavCreateManyInput = {
  id?: number
  userId: number
  active?: boolean
  title: string
  type: string
  director: string
  budget: string
  location: string
  duration: string
  time: string
  image: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type UserFavUpdateManyMutationInput = {
  active?: Prisma.BoolFieldUpdateOperationsInput | boolean
  title?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  director?: Prisma.StringFieldUpdateOperationsInput | string
  budget?: Prisma.StringFieldUpdateOperationsInput | string
  location?: Prisma.StringFieldUpdateOperationsInput | string
  duration?: Prisma.StringFieldUpdateOperationsInput | string
  time?: Prisma.StringFieldUpdateOperationsInput | string
  image?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type UserFavUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  active?: Prisma.BoolFieldUpdateOperationsInput | boolean
  title?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  director?: Prisma.StringFieldUpdateOperationsInput | string
  budget?: Prisma.StringFieldUpdateOperationsInput | string
  location?: Prisma.StringFieldUpdateOperationsInput | string
  duration?: Prisma.StringFieldUpdateOperationsInput | string
  time?: Prisma.StringFieldUpdateOperationsInput | string
  image?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type UserFavListRelationFilter = {
  every?: Prisma.UserFavWhereInput
  some?: Prisma.UserFavWhereInput
  none?: Prisma.UserFavWhereInput
}

export type UserFavOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type UserFavOrderByRelevanceInput = {
  fields: Prisma.UserFavOrderByRelevanceFieldEnum | Prisma.UserFavOrderByRelevanceFieldEnum[]
  sort: Prisma.SortOrder
  search: string
}

export type UserFavCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  active?: Prisma.SortOrder
  title?: Prisma.SortOrder
  type?: Prisma.SortOrder
  director?: Prisma.SortOrder
  budget?: Prisma.SortOrder
  location?: Prisma.SortOrder
  duration?: Prisma.SortOrder
  time?: Prisma.SortOrder
  image?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type UserFavAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type UserFavMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  active?: Prisma.SortOrder
  title?: Prisma.SortOrder
  type?: Prisma.SortOrder
  director?: Prisma.SortOrder
  budget?: Prisma.SortOrder
  location?: Prisma.SortOrder
  duration?: Prisma.SortOrder
  time?: Prisma.SortOrder
  image?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type UserFavMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  active?: Prisma.SortOrder
  title?: Prisma.SortOrder
  type?: Prisma.SortOrder
  director?: Prisma.SortOrder
  budget?: Prisma.SortOrder
  location?: Prisma.SortOrder
  duration?: Prisma.SortOrder
  time?: Prisma.SortOrder
  image?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type UserFavSumOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type UserFavCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.UserFavCreateWithoutUserInput, Prisma.UserFavUncheckedCreateWithoutUserInput> | Prisma.UserFavCreateWithoutUserInput[] | Prisma.UserFavUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.UserFavCreateOrConnectWithoutUserInput | Prisma.UserFavCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.UserFavCreateManyUserInputEnvelope
  connect?: Prisma.UserFavWhereUniqueInput | Prisma.UserFavWhereUniqueInput[]
}

export type UserFavUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.UserFavCreateWithoutUserInput, Prisma.UserFavUncheckedCreateWithoutUserInput> | Prisma.UserFavCreateWithoutUserInput[] | Prisma.UserFavUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.UserFavCreateOrConnectWithoutUserInput | Prisma.UserFavCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.UserFavCreateManyUserInputEnvelope
  connect?: Prisma.UserFavWhereUniqueInput | Prisma.UserFavWhereUniqueInput[]
}

export type UserFavUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.UserFavCreateWithoutUserInput, Prisma.UserFavUncheckedCreateWithoutUserInput> | Prisma.UserFavCreateWithoutUserInput[] | Prisma.UserFavUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.UserFavCreateOrConnectWithoutUserInput | Prisma.UserFavCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.UserFavUpsertWithWhereUniqueWithoutUserInput | Prisma.UserFavUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.UserFavCreateManyUserInputEnvelope
  set?: Prisma.UserFavWhereUniqueInput | Prisma.UserFavWhereUniqueInput[]
  disconnect?: Prisma.UserFavWhereUniqueInput | Prisma.UserFavWhereUniqueInput[]
  delete?: Prisma.UserFavWhereUniqueInput | Prisma.UserFavWhereUniqueInput[]
  connect?: Prisma.UserFavWhereUniqueInput | Prisma.UserFavWhereUniqueInput[]
  update?: Prisma.UserFavUpdateWithWhereUniqueWithoutUserInput | Prisma.UserFavUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.UserFavUpdateManyWithWhereWithoutUserInput | Prisma.UserFavUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.UserFavScalarWhereInput | Prisma.UserFavScalarWhereInput[]
}

export type UserFavUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.UserFavCreateWithoutUserInput, Prisma.UserFavUncheckedCreateWithoutUserInput> | Prisma.UserFavCreateWithoutUserInput[] | Prisma.UserFavUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.UserFavCreateOrConnectWithoutUserInput | Prisma.UserFavCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.UserFavUpsertWithWhereUniqueWithoutUserInput | Prisma.UserFavUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.UserFavCreateManyUserInputEnvelope
  set?: Prisma.UserFavWhereUniqueInput | Prisma.UserFavWhereUniqueInput[]
  disconnect?: Prisma.UserFavWhereUniqueInput | Prisma.UserFavWhereUniqueInput[]
  delete?: Prisma.UserFavWhereUniqueInput | Prisma.UserFavWhereUniqueInput[]
  connect?: Prisma.UserFavWhereUniqueInput | Prisma.UserFavWhereUniqueInput[]
  update?: Prisma.UserFavUpdateWithWhereUniqueWithoutUserInput | Prisma.UserFavUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.UserFavUpdateManyWithWhereWithoutUserInput | Prisma.UserFavUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.UserFavScalarWhereInput | Prisma.UserFavScalarWhereInput[]
}

export type UserFavCreateWithoutUserInput = {
  active?: boolean
  title: string
  type: string
  director: string
  budget: string
  location: string
  duration: string
  time: string
  image: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type UserFavUncheckedCreateWithoutUserInput = {
  id?: number
  active?: boolean
  title: string
  type: string
  director: string
  budget: string
  location: string
  duration: string
  time: string
  image: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type UserFavCreateOrConnectWithoutUserInput = {
  where: Prisma.UserFavWhereUniqueInput
  create: Prisma.XOR<Prisma.UserFavCreateWithoutUserInput, Prisma.UserFavUncheckedCreateWithoutUserInput>
}

export type UserFavCreateManyUserInputEnvelope = {
  data: Prisma.UserFavCreateManyUserInput | Prisma.UserFavCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type UserFavUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.UserFavWhereUniqueInput
  update: Prisma.XOR<Prisma.UserFavUpdateWithoutUserInput, Prisma.UserFavUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.UserFavCreateWithoutUserInput, Prisma.UserFavUncheckedCreateWithoutUserInput>
}

export type UserFavUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.UserFavWhereUniqueInput
  data: Prisma.XOR<Prisma.UserFavUpdateWithoutUserInput, Prisma.UserFavUncheckedUpdateWithoutUserInput>
}

export type UserFavUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.UserFavScalarWhereInput
  data: Prisma.XOR<Prisma.UserFavUpdateManyMutationInput, Prisma.UserFavUncheckedUpdateManyWithoutUserInput>
}

export type UserFavScalarWhereInput = {
  AND?: Prisma.UserFavScalarWhereInput | Prisma.UserFavScalarWhereInput[]
  OR?: Prisma.UserFavScalarWhereInput[]
  NOT?: Prisma.UserFavScalarWhereInput | Prisma.UserFavScalarWhereInput[]
  id?: Prisma.IntFilter<"UserFav"> | number
  userId?: Prisma.IntFilter<"UserFav"> | number
  active?: Prisma.BoolFilter<"UserFav"> | boolean
  title?: Prisma.StringFilter<"UserFav"> | string
  type?: Prisma.StringFilter<"UserFav"> | string
  director?: Prisma.StringFilter<"UserFav"> | string
  budget?: Prisma.StringFilter<"UserFav"> | string
  location?: Prisma.StringFilter<"UserFav"> | string
  duration?: Prisma.StringFilter<"UserFav"> | string
  time?: Prisma.StringFilter<"UserFav"> | string
  image?: Prisma.StringFilter<"UserFav"> | string
  createdAt?: Prisma.DateTimeFilter<"UserFav"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"UserFav"> | Date | string
}

export type UserFavCreateManyUserInput = {
  id?: number
  active?: boolean
  title: string
  type: string
  director: string
  budget: string
  location: string
  duration: string
  time: string
  image: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type UserFavUpdateWithoutUserInput = {
  active?: Prisma.BoolFieldUpdateOperationsInput | boolean
  title?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  director?: Prisma.StringFieldUpdateOperationsInput | string
  budget?: Prisma.StringFieldUpdateOperationsInput | string
  location?: Prisma.StringFieldUpdateOperationsInput | string
  duration?: Prisma.StringFieldUpdateOperationsInput | string
  time?: Prisma.StringFieldUpdateOperationsInput | string
  image?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type UserFavUncheckedUpdateWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  active?: Prisma.BoolFieldUpdateOperationsInput | boolean
  title?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  director?: Prisma.StringFieldUpdateOperationsInput | string
  budget?: Prisma.StringFieldUpdateOperationsInput | string
  location?: Prisma.StringFieldUpdateOperationsInput | string
  duration?: Prisma.StringFieldUpdateOperationsInput | string
  time?: Prisma.StringFieldUpdateOperationsInput | string
  image?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type UserFavUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  active?: Prisma.BoolFieldUpdateOperationsInput | boolean
  title?: Prisma.StringFieldUpdateOperationsInput | string
  type?: Prisma.StringFieldUpdateOperationsInput | string
  director?: Prisma.StringFieldUpdateOperationsInput | string
  budget?: Prisma.StringFieldUpdateOperationsInput | string
  location?: Prisma.StringFieldUpdateOperationsInput | string
  duration?: Prisma.StringFieldUpdateOperationsInput | string
  time?: Prisma.StringFieldUpdateOperationsInput | string
  image?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type UserFavSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  active?: boolean
  title?: boolean
  type?: boolean
  director?: boolean
  budget?: boolean
  location?: boolean
  duration?: boolean
  time?: boolean
  image?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  user?: boolean | Prisma.UserCredDefaultArgs<ExtArgs>
}, ExtArgs["result"]["userFav"]>



export type UserFavSelectScalar = {
  id?: boolean
  userId?: boolean
  active?: boolean
  title?: boolean
  type?: boolean
  director?: boolean
  budget?: boolean
  location?: boolean
  duration?: boolean
  time?: boolean
  image?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}

export type UserFavOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "userId" | "active" | "title" | "type" | "director" | "budget" | "location" | "duration" | "time" | "image" | "createdAt" | "updatedAt", ExtArgs["result"]["userFav"]>
export type UserFavInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserCredDefaultArgs<ExtArgs>
}

export type $UserFavPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "UserFav"
  objects: {
    user: Prisma.$UserCredPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: number
    userId: number
    active: boolean
    title: string
    type: string
    director: string
    budget: string
    location: string
    duration: string
    time: string
    image: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["userFav"]>
  composites: {}
}

export type UserFavGetPayload<S extends boolean | null | undefined | UserFavDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$UserFavPayload, S>

export type UserFavCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<UserFavFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: UserFavCountAggregateInputType | true
  }

export interface UserFavDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFav'], meta: { name: 'UserFav' } }
  /**
   * Find zero or one UserFav that matches the filter.
   * @param {UserFavFindUniqueArgs} args - Arguments to find a UserFav
   * @example
   * // Get one UserFav
   * const userFav = await prisma.userFav.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends UserFavFindUniqueArgs>(args: Prisma.SelectSubset<T, UserFavFindUniqueArgs<ExtArgs>>): Prisma.Prisma__UserFavClient<runtime.Types.Result.GetResult<Prisma.$UserFavPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one UserFav that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {UserFavFindUniqueOrThrowArgs} args - Arguments to find a UserFav
   * @example
   * // Get one UserFav
   * const userFav = await prisma.userFav.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends UserFavFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, UserFavFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__UserFavClient<runtime.Types.Result.GetResult<Prisma.$UserFavPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first UserFav that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserFavFindFirstArgs} args - Arguments to find a UserFav
   * @example
   * // Get one UserFav
   * const userFav = await prisma.userFav.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends UserFavFindFirstArgs>(args?: Prisma.SelectSubset<T, UserFavFindFirstArgs<ExtArgs>>): Prisma.Prisma__UserFavClient<runtime.Types.Result.GetResult<Prisma.$UserFavPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first UserFav that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserFavFindFirstOrThrowArgs} args - Arguments to find a UserFav
   * @example
   * // Get one UserFav
   * const userFav = await prisma.userFav.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends UserFavFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, UserFavFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__UserFavClient<runtime.Types.Result.GetResult<Prisma.$UserFavPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more UserFavs that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserFavFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all UserFavs
   * const userFavs = await prisma.userFav.findMany()
   * 
   * // Get first 10 UserFavs
   * const userFavs = await prisma.userFav.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const userFavWithIdOnly = await prisma.userFav.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends UserFavFindManyArgs>(args?: Prisma.SelectSubset<T, UserFavFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$UserFavPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a UserFav.
   * @param {UserFavCreateArgs} args - Arguments to create a UserFav.
   * @example
   * // Create one UserFav
   * const UserFav = await prisma.userFav.create({
   *   data: {
   *     // ... data to create a UserFav
   *   }
   * })
   * 
   */
  create<T extends UserFavCreateArgs>(args: Prisma.SelectSubset<T, UserFavCreateArgs<ExtArgs>>): Prisma.Prisma__UserFavClient<runtime.Types.Result.GetResult<Prisma.$UserFavPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many UserFavs.
   * @param {UserFavCreateManyArgs} args - Arguments to create many UserFavs.
   * @example
   * // Create many UserFavs
   * const userFav = await prisma.userFav.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends UserFavCreateManyArgs>(args?: Prisma.SelectSubset<T, UserFavCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Delete a UserFav.
   * @param {UserFavDeleteArgs} args - Arguments to delete one UserFav.
   * @example
   * // Delete one UserFav
   * const UserFav = await prisma.userFav.delete({
   *   where: {
   *     // ... filter to delete one UserFav
   *   }
   * })
   * 
   */
  delete<T extends UserFavDeleteArgs>(args: Prisma.SelectSubset<T, UserFavDeleteArgs<ExtArgs>>): Prisma.Prisma__UserFavClient<runtime.Types.Result.GetResult<Prisma.$UserFavPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one UserFav.
   * @param {UserFavUpdateArgs} args - Arguments to update one UserFav.
   * @example
   * // Update one UserFav
   * const userFav = await prisma.userFav.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends UserFavUpdateArgs>(args: Prisma.SelectSubset<T, UserFavUpdateArgs<ExtArgs>>): Prisma.Prisma__UserFavClient<runtime.Types.Result.GetResult<Prisma.$UserFavPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more UserFavs.
   * @param {UserFavDeleteManyArgs} args - Arguments to filter UserFavs to delete.
   * @example
   * // Delete a few UserFavs
   * const { count } = await prisma.userFav.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends UserFavDeleteManyArgs>(args?: Prisma.SelectSubset<T, UserFavDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more UserFavs.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserFavUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many UserFavs
   * const userFav = await prisma.userFav.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends UserFavUpdateManyArgs>(args: Prisma.SelectSubset<T, UserFavUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create or update one UserFav.
   * @param {UserFavUpsertArgs} args - Arguments to update or create a UserFav.
   * @example
   * // Update or create a UserFav
   * const userFav = await prisma.userFav.upsert({
   *   create: {
   *     // ... data to create a UserFav
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the UserFav we want to update
   *   }
   * })
   */
  upsert<T extends UserFavUpsertArgs>(args: Prisma.SelectSubset<T, UserFavUpsertArgs<ExtArgs>>): Prisma.Prisma__UserFavClient<runtime.Types.Result.GetResult<Prisma.$UserFavPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of UserFavs.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserFavCountArgs} args - Arguments to filter UserFavs to count.
   * @example
   * // Count the number of UserFavs
   * const count = await prisma.userFav.count({
   *   where: {
   *     // ... the filter for the UserFavs we want to count
   *   }
   * })
  **/
  count<T extends UserFavCountArgs>(
    args?: Prisma.Subset<T, UserFavCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], UserFavCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a UserFav.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserFavAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends UserFavAggregateArgs>(args: Prisma.Subset<T, UserFavAggregateArgs>): Prisma.PrismaPromise<GetUserFavAggregateType<T>>

  /**
   * Group by UserFav.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserFavGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends UserFavGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: UserFavGroupByArgs['orderBy'] }
      : { orderBy?: UserFavGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, UserFavGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFavGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the UserFav model
 */
readonly fields: UserFavFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for UserFav.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__UserFavClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  user<T extends Prisma.UserCredDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserCredDefaultArgs<ExtArgs>>): Prisma.Prisma__UserCredClient<runtime.Types.Result.GetResult<Prisma.$UserCredPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the UserFav model
 */
export interface UserFavFieldRefs {
  readonly id: Prisma.FieldRef<"UserFav", 'Int'>
  readonly userId: Prisma.FieldRef<"UserFav", 'Int'>
  readonly active: Prisma.FieldRef<"UserFav", 'Boolean'>
  readonly title: Prisma.FieldRef<"UserFav", 'String'>
  readonly type: Prisma.FieldRef<"UserFav", 'String'>
  readonly director: Prisma.FieldRef<"UserFav", 'String'>
  readonly budget: Prisma.FieldRef<"UserFav", 'String'>
  readonly location: Prisma.FieldRef<"UserFav", 'String'>
  readonly duration: Prisma.FieldRef<"UserFav", 'String'>
  readonly time: Prisma.FieldRef<"UserFav", 'String'>
  readonly image: Prisma.FieldRef<"UserFav", 'String'>
  readonly createdAt: Prisma.FieldRef<"UserFav", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"UserFav", 'DateTime'>
}
    

// Custom InputTypes
/**
 * UserFav findUnique
 */
export type UserFavFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserFav
   */
  select?: Prisma.UserFavSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserFav
   */
  omit?: Prisma.UserFavOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserFavInclude<ExtArgs> | null
  /**
   * Filter, which UserFav to fetch.
   */
  where: Prisma.UserFavWhereUniqueInput
}

/**
 * UserFav findUniqueOrThrow
 */
export type UserFavFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserFav
   */
  select?: Prisma.UserFavSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserFav
   */
  omit?: Prisma.UserFavOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserFavInclude<ExtArgs> | null
  /**
   * Filter, which UserFav to fetch.
   */
  where: Prisma.UserFavWhereUniqueInput
}

/**
 * UserFav findFirst
 */
export type UserFavFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserFav
   */
  select?: Prisma.UserFavSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserFav
   */
  omit?: Prisma.UserFavOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserFavInclude<ExtArgs> | null
  /**
   * Filter, which UserFav to fetch.
   */
  where?: Prisma.UserFavWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of UserFavs to fetch.
   */
  orderBy?: Prisma.UserFavOrderByWithRelationInput | Prisma.UserFavOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for UserFavs.
   */
  cursor?: Prisma.UserFavWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` UserFavs from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` UserFavs.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of UserFavs.
   */
  distinct?: Prisma.UserFavScalarFieldEnum | Prisma.UserFavScalarFieldEnum[]
}

/**
 * UserFav findFirstOrThrow
 */
export type UserFavFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserFav
   */
  select?: Prisma.UserFavSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserFav
   */
  omit?: Prisma.UserFavOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserFavInclude<ExtArgs> | null
  /**
   * Filter, which UserFav to fetch.
   */
  where?: Prisma.UserFavWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of UserFavs to fetch.
   */
  orderBy?: Prisma.UserFavOrderByWithRelationInput | Prisma.UserFavOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for UserFavs.
   */
  cursor?: Prisma.UserFavWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` UserFavs from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` UserFavs.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of UserFavs.
   */
  distinct?: Prisma.UserFavScalarFieldEnum | Prisma.UserFavScalarFieldEnum[]
}

/**
 * UserFav findMany
 */
export type UserFavFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserFav
   */
  select?: Prisma.UserFavSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserFav
   */
  omit?: Prisma.UserFavOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserFavInclude<ExtArgs> | null
  /**
   * Filter, which UserFavs to fetch.
   */
  where?: Prisma.UserFavWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of UserFavs to fetch.
   */
  orderBy?: Prisma.UserFavOrderByWithRelationInput | Prisma.UserFavOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing UserFavs.
   */
  cursor?: Prisma.UserFavWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` UserFavs from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` UserFavs.
   */
  skip?: number
  distinct?: Prisma.UserFavScalarFieldEnum | Prisma.UserFavScalarFieldEnum[]
}

/**
 * UserFav create
 */
export type UserFavCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserFav
   */
  select?: Prisma.UserFavSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserFav
   */
  omit?: Prisma.UserFavOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserFavInclude<ExtArgs> | null
  /**
   * The data needed to create a UserFav.
   */
  data: Prisma.XOR<Prisma.UserFavCreateInput, Prisma.UserFavUncheckedCreateInput>
}

/**
 * UserFav createMany
 */
export type UserFavCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many UserFavs.
   */
  data: Prisma.UserFavCreateManyInput | Prisma.UserFavCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * UserFav update
 */
export type UserFavUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserFav
   */
  select?: Prisma.UserFavSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserFav
   */
  omit?: Prisma.UserFavOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserFavInclude<ExtArgs> | null
  /**
   * The data needed to update a UserFav.
   */
  data: Prisma.XOR<Prisma.UserFavUpdateInput, Prisma.UserFavUncheckedUpdateInput>
  /**
   * Choose, which UserFav to update.
   */
  where: Prisma.UserFavWhereUniqueInput
}

/**
 * UserFav updateMany
 */
export type UserFavUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update UserFavs.
   */
  data: Prisma.XOR<Prisma.UserFavUpdateManyMutationInput, Prisma.UserFavUncheckedUpdateManyInput>
  /**
   * Filter which UserFavs to update
   */
  where?: Prisma.UserFavWhereInput
  /**
   * Limit how many UserFavs to update.
   */
  limit?: number
}

/**
 * UserFav upsert
 */
export type UserFavUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserFav
   */
  select?: Prisma.UserFavSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserFav
   */
  omit?: Prisma.UserFavOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserFavInclude<ExtArgs> | null
  /**
   * The filter to search for the UserFav to update in case it exists.
   */
  where: Prisma.UserFavWhereUniqueInput
  /**
   * In case the UserFav found by the `where` argument doesn't exist, create a new UserFav with this data.
   */
  create: Prisma.XOR<Prisma.UserFavCreateInput, Prisma.UserFavUncheckedCreateInput>
  /**
   * In case the UserFav was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.UserFavUpdateInput, Prisma.UserFavUncheckedUpdateInput>
}

/**
 * UserFav delete
 */
export type UserFavDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserFav
   */
  select?: Prisma.UserFavSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserFav
   */
  omit?: Prisma.UserFavOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserFavInclude<ExtArgs> | null
  /**
   * Filter which UserFav to delete.
   */
  where: Prisma.UserFavWhereUniqueInput
}

/**
 * UserFav deleteMany
 */
export type UserFavDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which UserFavs to delete
   */
  where?: Prisma.UserFavWhereInput
  /**
   * Limit how many UserFavs to delete.
   */
  limit?: number
}

/**
 * UserFav without action
 */
export type UserFavDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserFav
   */
  select?: Prisma.UserFavSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserFav
   */
  omit?: Prisma.UserFavOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserFavInclude<ExtArgs> | null
}
